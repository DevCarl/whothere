---
title: "Multinomial logistic regression report"
author: "Silvia Saloni"
date: "Thursday, July 28, 2016"
output: pdf_document
---

#Introduction

The aim of the project was to be able to find a model that best predict the relationship between:
* the number of people counted with the survey for a given class at a particular hour 
* Wi-fi log counted in that room at that hour

This will allow to see whether Wi-Fi log is a good predictor for estimating occupancy in a classroom.

Given the fact that the target feature was a percentage we tried to run a logistic regression to predict when the room was more likely to be empty or occupied. 

Below we describes step by step all the analysis performed.

## ANALYSIS

### DATABASE CONNECTION AND DATASET

```{r, echo=FALSE, warning=FALSE}
#load all the libraries needed
library(RMySQL) #package for communicate with MySQL database
library(ggplot2) #package for making graphs
library(GGally)
library(nlme)
library(caret) # for splitting the database
library(DAAG)#for k-fold validation on linear and logistic
library(boot)#for k-fold validation on glm
library(plyr)
library(reshape2)
source("http://peterhaschke.com/Code/multiplot.R") 
```

First of all, we set up the connection to the database, using the following code:

```{r}
connection <- dbConnect(MySQL(),user="root", password="",dbname="who_there_db", host="localhost")
```  
Then we made a query to the database, in order to get all the groundth truth data collected in room B.002, B.004 and B.006 from 9 to 17 and the correspondent Wi-Fi Log measured in that time frame and rooms. 

```{r, echo=FALSE, warning=FALSE}
query <-"SELECT W.`Room_Room_id` as Room, W.`Date`, HOUR( W.Time ) as Time, T.`Module_Module_code` as Module, M.`Course_Level`,T.`Tutorial`, T.`Double_module`, T.`Class_went_ahead`, R.`Capacity`, G.`Percentage_room_full`, AVG(W.`Associated_client_counts`) as Wifi_Average_clients, MAX(W.`Authenticated_client_counts`) as Wifi_Max_clients FROM Room R, Wifi_log W, Ground_truth_data G, Time_table T, Module M WHERE W.Room_Room_id = R.Room_id AND G.Room_Room_id = W.Room_Room_id AND W.Date = G.Date AND HOUR( W.Time ) = HOUR( G.Time ) AND HOUR( W.Time ) = HOUR( T.Time_period ) AND T.Date = W.Date AND T.Room_Room_id = W.Room_Room_id AND M.`Module_code` = T.`Module_Module_code` GROUP BY W.Room_Room_id, HOUR( W.Time ) , W.Date"

#select the data based on the query and store them in a dataframe called Analysis table
AnalysisTable <-dbGetQuery(connection, query)  
```

The dataset created had in total 216 rows and it will allow us to explore if Wi-Fi log can estimate precisely if a room is empty or occupied during a certain hour.

As a **target features** for the multinomial logistic regression we decided to create a categorical features with 4 levels using the percentage of the room full. In particular, the levels were:
* Low occupancy with an occupancy between 0 and 25%;
* Mid Low occupancy, which ranges from 25-50% of occupancy;
* Mid High occupancy, which contain obeservation between 50-75%;
* High Occupancy with an occupancy range between 75-100%.

```{r, echo=FALSE, warning=FALSE}
#bin percentage_room_full into a categorical variable
AnalysisTable$Binned_Occupancy <-cut(AnalysisTable$Percentage_room_full, breaks = 4, right=FALSE, labels=c('Low','Mid_Low','Mid_High', 'High'))
```
As response variables or feature we considered Wi-Fi logs, which were summarised either as average of the logs counted for each room and for each hour or as maximum of the logs measured for each room and for each hour. 

Together with the Wi-Fi log, we included in the data set the following features: 

* **Date**, which we did not use in this analysis, because they just cover 2 weeks of Novemeber, but for future analyses they can be used to group observations by seasons or semesters or to finds seasonal trends for time series analyses.

* **Time**, which will be explored either as continous variable and as categorical to explore if the time of the day can have an affect on the Wi-Fi log. To do so we, bin the time in 4 ranges: early morning (9-11), late morning (11-13), early afternoon (13-15) and late afternoon (15-17). This will allow us to see if the Wi-Fi log accuracy was changing during the day. For example, it is more likely that all the electronic devices are fully powered early in the morning and consequently the Wi-fi log data can be more accurate or overestimating the occupancy of the room (i.e. more than one device per person). On the contrary in the afternoon, the devices may be more likely to be out of battery and it is possible that there are less devices in the room.
```{r, echo=FALSE, warning=FALSE}
AnalysisTable$Factor_Time <-cut(AnalysisTable$Time, breaks = 4, right=FALSE, labels=c('Early Morning','Late Morning','Early Afternoon','Late Afternoon' ))
```

* **Module**, which we are not going to include in the analysis because the majority of the module present are for computer science, but for future analyses it will be possible to explore if the Wi-fi log accuracy in predicting the occupancy change acroos the courses. Science course or computer science course will more likely to use electronic devices during lecture than art students.

* **Course level**, which can indicate us whether electronic devices will be less used during different course level. For example, first and second level courses can be less practical and therefore laptop are not needed and that can decrease the number of devices connected. On the other hand, undergraduate might be more distracted during lecture and look at their phones during lectures. This will result in an increase of connection in that hour.

```{r, echo=FALSE, warning=FALSE}
AnalysisTable$Course_Level <- factor(AnalysisTable$Course_Level)
```

* **Tutorial**, which can affect the number of logged people. First of all, because tutorial divided the room in 2 and therefore there will be measured less people than expected. 
```{r, echo=FALSE, warning=FALSE}
AnalysisTable$Double_module <- factor(AnalysisTable$Double_module)
AnalysisTable$Class_went_ahead <- factor(AnalysisTable$Class_went_ahead)
```

* **Double_module**, categorical variable indicating wether in the class there are more than one module, increasing the number of people expected in the room.
```{r, echo=FALSE}
AnalysisTable$Double_module <- factor(AnalysisTable$Double_module)
```

* **Double_module**, categorical variable indicating wether in the class went ahead to check for false positive.
```{r, echo=FALSE}
AnalysisTable$Class_went_ahead <- factor(AnalysisTable$Class_went_ahead)
```

The resulting data set is printed below:
```{r}
head(AnalysisTable)
```

## DATA QUALITY REPORT  

Before running any analyses, we carried out the data quality report to check for any issue related to the variable (e.g. outlier, skewed distribution, NaN values) and solutions we will implement to solve them.

Initially set all the categorical variables as factors and then we printed the descriptive statistic for all the features.
```{r}
summary(AnalysisTable)
```
From this we could see that NaN values were not present in the data set. 
We could notice that the observations for the features Tutorials and Double_model were not even distributed across the 2 levels of the variables. In fact, only 6 observations were present for tutorial class and for double module class. Therefore, we decided to discard both the features, because they will be not informative for the analysis. Similarly for the feature class_went_ahead the majority of the lectures did occur and we decided to discard it.
Furthermore for the variables Wifi_Average_clients and Wifi_Max_clients, it seems that there are few outliers, since the median is lower than the mean and the max values are far higher than the mean values. We will going to explore this issues with histogram and boxplots.

### Exploratory graphs
For exploring possible issues related with the continuous variables we plotted histograms and boxplots.

### Histograms

```{r, echo=FALSE,warning=FALSE}
#histogram for showing the count in each bin for the Maximum number of clients
histo1 <- ggplot(AnalysisTable, aes(x = Wifi_Max_clients)) + geom_histogram(binwidth = 10,  col="red", aes(fill=..count..)) + scale_fill_gradient("Count", low = "yellow", high = "red") +theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

#histogram for showing the count in each bin for the Average number of clients
histo2 <- ggplot(AnalysisTable, aes(x = Wifi_Average_clients)) + geom_histogram(binwidth = 10,  col="red", aes(fill=..count..)) + scale_fill_gradient("Count", low = "yellow", high = "red") +theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

#histogram for showing the count in each bin for each hour of the day
histo3 <- ggplot(AnalysisTable, aes(x = Time)) + geom_histogram(binwidth = 2,  col="red", aes(fill=..count..)) + scale_fill_gradient("Count", low = "yellow", high = "red") +theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

#plot all the histograms in one window
multiplot(histo1, histo2, histo3, cols=2)
```

<br><br><br>
Form the histograms we could see that the distribution of the feature Wifi Maximum_client (i.e. the Maximum number of devices logged in one hour lecture) was skewed to the left, indicating that the in the majority of the lecture were counted no more than 40 people. Furthermore, we could see that there are potential outliers (values > 150). Similar pattern was observed for the feature Wifi_Average_clients.
Feature times had as well a skewed distribution, suggesting that the majority of the lectures were concentrating during the early morning and they were decreasing towards the afternoon.
<br><br><br>
#### Boxplots
<br>
  
```{r, echo=FALSE, warning=FALSE}
#make the boxplot for continuous variable
#box plot for the counted client varable
box1 <- ggplot(AnalysisTable, aes(x = factor(0), y = Wifi_Average_clients)) + geom_boxplot() + xlab("Average counted clients") + ylab("")+ scale_x_discrete(breaks = NULL)  + theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

#box plot for the maximum number of clients variable
box2 <- ggplot(AnalysisTable, aes(x = factor(0), y =Wifi_Max_clients)) + geom_boxplot() + xlab("Maximum counted clients") + ylab("")+ scale_x_discrete(breaks = NULL) + theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

#box plot for the Time continuous variable
box3 <- ggplot(AnalysisTable, aes(x = factor(0), y = Time)) + geom_boxplot() + xlab("Time") + ylab("")+ scale_x_discrete(breaks = NULL) + theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 
#plot all the boxplots in one window
multiplot(box1, box2, box3, cols=2)
```  
<br><br>

From the boxplots, all the trends observed in the histograms were confirmed.

For categorical variables we plot bar plot graphs.  

#### Bar plots  

```{r, echo=FALSE, warning=FALSE}

bar1 <- ggplot(AnalysisTable, aes(x = Room)) + geom_bar(fill="orangered2")+ theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

#bar plot for the categorical variable: Course level
bar2 <- ggplot(AnalysisTable, aes(x = Course_Level)) + geom_bar(fill="orangered2")+ theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

#bar plot for the categorical variable: Time as factor
bar3 <- ggplot(AnalysisTable, aes(x = Factor_Time)) + geom_bar(fill="orangered2")+ theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

#plot all the barplots in one window
multiplot(bar1, bar2, bar3, cols=2)
```
<br><br>
From the barplots, we could see that observations were equally distributed across all the levels of the feature Room and Factor Time. On the contrary, there were more observations for level3 and 4 courses and no lecture. The majority of the classes resulted to have an occupancy around 25-50%. No issues were detected for those features.  

#### Summary
<br><br>

Features               | Issues                                   | Planned Solution             
-----------------------|------------------------------------------|----------------------------
Room                   |None                                      |None
Time                   |Distibution skewed to the left            |To solve during analysis 
Factor Time            |None                                      |None
Course level           |None                                      |None
Tutorial               |Uneven representation of the level        |Discarded from the analysis
Double Module          |Uneven representation of the level        |Discarded from the analysis
Class went ahead       |Uneven representation of the level        |Discarded from the analysis
Wifi Average clients   |Distibution skewed to the left \& outliers|To solve during analysis
Wifi Maximum clients   |Distibution skewed to the left \& outliers|To solve during analysis
Binned Occupancy       |None                                      |None

<br><br>

## FEATURES AFFECTING THE TARGET FEATURE  

The next step of the analysis was to see which feature really affect the target feature for deciding which features we would include into the model.  
 
For the continuous features we used box plots, while for categorical we use bar plots.

### Boxplots
```{r,echo=FALSE,warning=FALSE}
pairbox1 <- ggplot(AnalysisTable, aes(x = Binned_Occupancy, y =Wifi_Average_clients)) + geom_boxplot()+ theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

pairbox2 <- ggplot(AnalysisTable, aes(x = Binned_Occupancy, y = Wifi_Max_clients)) + geom_boxplot() + theme_bw()+theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

pairbox3 <- ggplot(AnalysisTable, aes(x =Binned_Occupancy, y = Time )) + geom_boxplot() + theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")) 

multiplot(pairbox1, pairbox2, pairbox3, cols=3)
```
<br><br><br>

From the boxplots we could see that when the room was indicated as empty either the average and the maximum Wi-Fi logs were close to zero and they were increasing across the level of the binned occupancy, showing that either average Binary_Occupancy and maximum wifi counted clients are a good predictor of the binary occupancy and we are going to run 2 models: one for exploring the relationship between Binary_Occupancy and Average counted clients and another for Survey counted clients and Maximum counted clients. The difference between the levels will probably be higher without the outliers and we might run the model without them to see if the accuracy will increase.
The occupacy seems to not change with the time, so were not going to explore it.

## Barplots 

```{r,echo=TRUE,warning=FALSE}
barpair1 <-ggplot(AnalysisTable, aes(x = Room, fill = Binned_Occupancy)) + geom_bar(position = "dodge")+ scale_fill_manual(values=c( "darkblue","cyan4","orange", "yellow"))+theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))

barpair2 <-ggplot(AnalysisTable, aes(x = Factor_Time, fill =Binned_Occupancy)) + geom_bar(position = "dodge")+ scale_fill_manual(values=c( "darkblue","cyan4","orange", "yellow"))+theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))

barpair3 <-ggplot(AnalysisTable, aes(x = Course_Level, fill = Binned_Occupancy)) + geom_bar(position = "dodge")+ scale_fill_manual(values=c( "darkblue","cyan4","orange", "yellow"))+theme_bw()+theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))

multiplot(barpair1, barpair2, barpair3, cols=2)
```
All the ranges of occupancy were equally represented in all the three rooms, indicating that room was not affecting the ocuupancy.
The occupancy level tend to change across the levels of course levels. Level1 and level2 courses had an higher Mid-low and Mid-high occupancy, while all the other levels had a higher low and mid-low occupancy. This was expected for level 0, where we expect no lecture is running. Therefore, we are considering all those features in the model.

### Interacting effect on the target feature  
<br>
For selecting the features that together with the max logs or with the average logs best predict the ground truth data we will do model selection using AIC values.     
For doing so, we decided to considered the models that better suited our hypothesis and they are the following:

* $Binned occupancy \~ 1$, the null model;

* $Binned occupancy \~ Average Wifi occupancy$, for testing whether average Wi-Fi counting logs were accurately predicting the occupancy of the room;

* $Binned occupancy \~ Average Wifi occupancy + Room$, for testing whether average Wi-Fi counting logs and the room were were accurately predicting the occupancy of the room;

* $Binned occupancy \~ Average Wifi occupancy + Time$, for testing whether average Wi-Fi counting logs and the time of the day were accurately predicting the occupancy of the room;

* $Binned occupancy \~ Average Wifi occupancy + Course_Level$, for testing whether average Wi-Fi counting logs and course levels were accurately predicting the occupancy of the room;

* $Binned occupancy \~ Average Wifi occupancy + Room + Time$, for testing whether average Wi-Fi counting logs, room type and the time of the day were accurately predicting the occupancy of the room;
* $Binned occupancy \~ Average Wifi occupancy + Room + Course_Level$, for testing whether average Wi-Fi counting logs, room type and course levels were accurately predicting the occupancy of the room;
* $Binned occupancy \~ Average Wifi occupancy + Time + Course_Level$, for testing whether average Wi-Fi counting logs, the time of the day and the course levels were accurately predicting the occupancy of the room;

* $Binned occupancy \~ Average Wifi occupancy + Room + Time + Course_Level$, for testing whether average Wi-Fi counting logs, rooms, the time of the day and the course levels were accurately predicting the occupancy of the room;

The same models were run also with the occupancy estimated with the maximum number of logs measured in that hour. All these models were run using the k-fold cross. K-fold validation was preferred over the validation set approach and the Leave Out Cross Validation (LOOCV), because it is more robust and more accurate in estimating the test error. The Validation set approach tends to give an over estimate of the test error and the test error is dependent on the observations included randomly in the test set. Furthermore, the LOOCV tends to provide a test error with a high variance, because the folds used to calculating it are correlated among each other. 
In particular in this analysis we are going to perform a 10-fold cross validation, which is pretty standard.

The 10 fold cross validation was carried out manually using the package carret, as showed in the following tutorial: http://amunategui.github.io/multinomial-neuralnetworks-walkthrough/. For each model we estract the overall mean square error(MSE) and we picked as best model the model with the lowest MSE.

#Results

## CASE1: Wi-Fi Average logs

# Analysis
<br>
For running the logistic regression we performed k fold cross validation with the aim of testing if the selected model can be applied to new datasets. K fold validation was preferred over the validationset approach and the Leave Out Cross Validation (LOOCV), because it is more robust and more accurate in estimating the test error. The Validation set approach tends to give an over estimate of the test error and the test error is dependent on the observations included randomly in the test set. Furthermore, the LOOCV tends to provide a test error with a high variance, because the folds used to calculating it are correlated among each other. 
In particular in this analysis we are going to perform a 10 fold cross validation, which is pretty standard.
<br>

# Results

#ANALYSIS
set.seed(1000)
cv <- 10
cvDivider <- floor(nrow(AnalysisTable)/(cv+1))

#MULTINOMIAL REGRESSION
#null model
totalAccuracy.null <- c()
totalAIC.null <- c()
  
for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  null <- multinom(Binned_Occupancy ~ 1, data=dataTrain,maxit=1000, trace = T)
  pred.null <- predict(null, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.null <- postResample(dataTest$Binned_Occupancy, pred.null)[[1]]
  print(paste('Current Accuracy for null model:',cv_ac.null,'for CV:',cv))
  totalAccuracy.null <- c(totalAccuracy.null, cv_ac.null)
  #AIC
  print(paste('Current AIC:',AIC(null), 'for CV', cv))
  totalAIC.null <- c(totalAIC.null, AIC(null))
}

#CASE1: AVERAGE MODEL

#avg model
totalAccuracy.avg <- c()
totalAIC.avg <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  avg <- multinom(Binned_Occupancy ~ Wifi_Average_logs, data=dataTrain,maxit=1000, trace = T)
  pred.avg <- predict(avg, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.avg <- postResample(dataTest$Binned_Occupancy, pred.avg)[[1]]
  print(paste('Current Accuracy for avg model:',cv_ac.avg,'for CV:',cv))
  totalAccuracy.avg <- c(totalAccuracy.avg, cv_ac.avg)
  #AIC
  print(paste('Current AIC:',AIC(avg), 'for CV', cv))
  totalAIC.avg <- c(totalAIC.avg, AIC(avg))
}


#avg.room model
totalAccuracy.avg.room <- c()
totalAIC.avg.room <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  avg.room <- multinom(Binned_Occupancy ~ Wifi_Average_logs+Room, data=dataTrain,maxit=1000, trace = T)
  pred.avg.room <- predict(avg.room, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.avg.room <- postResample(dataTest$Binned_Occupancy, pred.avg.room)[[1]]
  print(paste('Current Accuracy for avg model:',cv_ac.avg.room,'for CV:',cv))
  totalAccuracy.avg.room <- c(totalAccuracy.avg.room, cv_ac.avg.room)
  #AIC
  print(paste('Current AIC:',AIC(avg.room), 'for CV', cv))
  totalAIC.avg.room <- c(totalAIC.avg.room, AIC(avg.room))
}


#avg.time model
totalAccuracy.avg.time <- c()
totalAIC.avg.time <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  avg.time <- multinom(Binned_Occupancy ~ Wifi_Average_logs+Factor_Time, data=dataTrain,maxit=1000, trace = T)
  pred.avg.time <- predict(avg.time, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.avg.time <- postResample(dataTest$Binned_Occupancy, pred.avg.time)[[1]]
  print(paste('Current Accuracy for avg model:',cv_ac.avg.time,'for CV:',cv))
  totalAccuracy.avg.time <- c(totalAccuracy.avg.time, cv_ac.avg.time)
  #AIC
  print(paste('Current AIC:',AIC(avg.time), 'for CV', cv))
  totalAIC.avg.time <- c(totalAIC.avg.time, AIC(avg.time))
}

#avg.level model
totalAccuracy.avg.level <- c()
totalAIC.avg.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  avg.level <- multinom(Binned_Occupancy ~ Wifi_Average_logs+ Course_Level, data=dataTrain,maxit=1000, trace = T)
  pred.avg.level <- predict(avg.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.avg.level <- postResample(dataTest$Binned_Occupancy, pred.avg.level)[[1]]
  print(paste('Current Accuracy for avg model:',cv_ac.avg.level,'for CV:',cv))
  totalAccuracy.avg.level <- c(totalAccuracy.avg.level, cv_ac.avg.level)
  
  #AIC
  print(paste('Current AIC:',AIC(avg.level), 'for CV', cv))
  totalAIC.avg.level <- c(totalAIC.avg.level, AIC(avg.level))
}

#avg.room.time model
totalAccuracy.avg.room.time <- c()
totalAIC.avg.room.time <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  avg.room.time <- multinom(Binned_Occupancy ~ Wifi_Average_logs+Room+Factor_Time, data=dataTrain,maxit=1000, trace = T)
  pred.avg.room.time <- predict(avg.room.time, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.avg.room.time <- postResample(dataTest$Binned_Occupancy, pred.avg.room.time)[[1]]
  print(paste('Current Accuracy for avg model:',cv_ac.avg.room.time,'for CV:',cv))
  totalAccuracy.avg.room.time<- c(totalAccuracy.avg.room.time, cv_ac.avg.room.time)
  
  #AIC
  print(paste('Current AIC:',AIC(avg.room.time), 'for CV', cv))
  totalAIC.avg.room.time <- c(totalAIC.avg.room.time, AIC(avg.room.time))
}

#avg.room.level model
totalAccuracy.avg.room.level <- c()
totalAIC.avg.room.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  avg.room.level <- multinom(Binned_Occupancy ~ Wifi_Average_logs+Room+Course_Level, data=dataTrain,maxit=1000, trace = T)
  pred.avg.room.level <- predict(avg.room.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.avg.room.level <- postResample(dataTest$Binned_Occupancy, pred.avg.room.level)[[1]]
  print(paste('Current Accuracy for avg model:',cv_ac.avg.room.level,'for CV:',cv))
  totalAccuracy.avg.room.level<- c(totalAccuracy.avg.room.level, cv_ac.avg.room.level)
  
  #AIC
  print(paste('Current AIC:',AIC(avg.room.level), 'for CV', cv))
  totalAIC.avg.room.level <- c(totalAIC.avg.room.level, AIC(avg.room.level))
}

#avg.time.level model
totalAccuracy.avg.time.level <- c()
totalAIC.avg.time.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  avg.time.level <- multinom(Binned_Occupancy ~ Wifi_Average_logs+Factor_Time+Course_Level, data=dataTrain,maxit=1000, trace = T)
  pred.avg.time.level <- predict(avg.time.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.avg.time.level <- postResample(dataTest$Binned_Occupancy, pred.avg.time.level)[[1]]
  print(paste('Current Accuracy for avg model:',cv_ac.avg.time.level,'for CV:',cv))
  totalAccuracy.avg.time.level<- c(totalAccuracy.avg.time.level, cv_ac.avg.time.level)
  
  #AIC
  print(paste('Current AIC:',AIC(avg.time.level), 'for CV', cv))
  totalAIC.avg.time.level <- c(totalAIC.avg.time.level, AIC(avg.time.level))
}

#full model
totalAccuracy.avg.full <- c()
totalAIC.avg.full <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  avg.full <- multinom(Binned_Occupancy ~Wifi_Average_logs + Room + Factor_Time + Course_Level, data=dataTrain,maxit=1000, trace = T)
  pred.avg.full <- predict(avg.full, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.avg.full <- postResample(dataTest$Binned_Occupancy, pred.avg.full)[[1]]
  print(paste('Current Accuracy for full model:',cv_ac.avg.full,'for CV:',cv))
  totalAccuracy.avg.full <- c(totalAccuracy.avg.full, cv_ac.avg.full)
  
  #AIC
  print(paste('Current AIC:',AIC(avg.full), 'for CV', cv))
  totalAIC.avg.full <- c(totalAIC.avg.full, AIC(avg.full))
}

#ACCURACIES
#NULL MODEL
print(paste('The accuracy for null model is:',mean(totalAccuracy.null),' and the AIC is:',mean(totalAIC.null)))
#AVG MODEL
print(paste('The accuracy for avg model is:',mean(totalAccuracy.avg),' and the AIC is:',mean(totalAIC.avg)))
#AVG.ROOM
print(paste('The accuracy for avg.room model is:',mean(totalAccuracy.avg.room),' and the AIC is:',mean(totalAIC.avg.room)))
#AVG.TIME
print(paste('The accuracy for avg.time model is:',mean(totalAccuracy.avg.time),' and the AIC is:',mean(totalAIC.avg.time)))
#AVG.LEVEL
print(paste('The accuracy for avg.level model is:',mean(totalAccuracy.avg.time),' and the AIC is:',mean(totalAIC.avg.time)))
#AVG.ROOM.TIME
print(paste('The accuracy for avg.room.time model is:',mean(totalAccuracy.avg.room.time),' and the AIC is:',mean(totalAIC.avg.room.time)))
#AVG.ROOM.LEVEL
print(paste('The accuracy for avg.room.level model is:',mean(totalAccuracy.avg.room.level),' and the AIC is:',mean(totalAIC.avg.room.level)))
#AVG.TIME.LEVEL
print(paste('The accuracy for avg.time.level model is:',mean(totalAccuracy.avg.time.level),' and the AIC is:',mean(totalAIC.avg.time.level)))
#AVG.FULL
print(paste('The accuracy for avg.full model is:',mean(totalAccuracy.avg.full),' and the AIC is:',mean(totalAIC.avg.full)))

#The best model in term of accuracy and AIC was AVG.ROOM with acc = 0.58  and AIC is: 364

#CASE2: MAX MODELS

#max model
totalAccuracy.max <- c()
totalAIC.max <- c()
for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  max <- multinom(Binned_Occupancy ~ Wifi_Max_logs, data=dataTrain,maxit=1000, trace = T)
  pred.max <- predict(max, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.max <- postResample(dataTest$Binned_Occupancy, pred.max)[[1]]
  print(paste('Current Accuracy for max model:',cv_ac.max,'for CV:',cv))
  totalAccuracy.max <- c(totalAccuracy.max, cv_ac.max)
  #AIC
  print(paste('Current AIC:',AIC(max), 'for CV', cv))
  totalAIC.max <- c(totalAIC.max, AIC(max))
}

#max.room model
totalAccuracy.max.room <- c()
totalAIC.max.room <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  max.room <- multinom(Binned_Occupancy ~ Wifi_Max_logs+Room, data=dataTrain,maxit=1000, trace = T)
  pred.max.room <- predict(max.room, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.max.room <- postResample(dataTest$Binned_Occupancy, pred.max.room)[[1]]
  print(paste('Current Accuracy for max model:',cv_ac.max.room,'for CV:',cv))
  totalAccuracy.max.room <- c(totalAccuracy.max.room, cv_ac.max.room)
  
  #AIC
  print(paste('Current AIC:',AIC(max.room), 'for CV', cv))
  totalAIC.max.room <- c(totalAIC.max.room, AIC(max.room))
}

#max.time model
totalAccuracy.max.time <- c()
totalAIC.max.time <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  max.time <- multinom(Binned_Occupancy ~ Wifi_Max_logs+Factor_Time, data=dataTrain,maxit=1000, trace = T)
  pred.max.time <- predict(max.time, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.max.time <- postResample(dataTest$Binned_Occupancy, pred.max.time)[[1]]
  print(paste('Current Accuracy for max model:',cv_ac.max.time,'for CV:',cv))
  totalAccuracy.max.time <- c(totalAccuracy.max.time, cv_ac.max.time)
  
  #AIC
  print(paste('Current AIC:',AIC(max.time), 'for CV', cv))
  totalAIC.max.time <- c(totalAIC.max.time, AIC(max.time))
}

#max.level model
totalAccuracy.max.level <- c()
totalAIC.max.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  max.level <- multinom(Binned_Occupancy ~ Wifi_Max_logs+Course_Level, data=dataTrain,maxit=1000, trace = T)
  pred.max.level <- predict(max.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.max.level <- postResample(dataTest$Binned_Occupancy, pred.max.level)[[1]]
  print(paste('Current Accuracy for max model:',cv_ac.max.level,'for CV:',cv))
  totalAccuracy.max.level <- c(totalAccuracy.max.level, cv_ac.max.level)
  
  #AIC
  print(paste('Current AIC:',AIC(max.level), 'for CV', cv))
  totalAIC.max.level <- c(totalAIC.max.level, AIC(max.level))
}

#max.room.time model
totalAccuracy.max.room.time <- c()
totalAIC.max.room.time <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  max.room.time <- multinom(Binned_Occupancy ~ Wifi_Max_logs+Room+Factor_Time, data=dataTrain,maxit=1000, trace = T)
  pred.max.room.time <- predict(max.room.time, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.max.room.time <- postResample(dataTest$Binned_Occupancy, pred.max.room.time)[[1]]
  print(paste('Current Accuracy for max model:',cv_ac.max.room.time,'for CV:',cv))
  totalAccuracy.max.room.time<- c(totalAccuracy.max.room.time, cv_ac.max.room.time)
  
  #AIC
  print(paste('Current AIC:',AIC(max.room.time), 'for CV', cv))
  totalAIC.max.room.time <- c(totalAIC.max.room.time, AIC(max.room.time))
}

#max.room.level model
totalAccuracy.max.room.level <- c()
totalAIC.max.room.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  max.room.level <- multinom(Binned_Occupancy ~ Wifi_Max_logs+Room+Course_Level, data=dataTrain,maxit=1000, trace = T)
  pred.max.room.level <- predict(max.room.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.max.room.level <- postResample(dataTest$Binned_Occupancy, pred.max.room.level)[[1]]
  print(paste('Current Accuracy for max model:',cv_ac.max.room.level,'for CV:',cv))
  totalAccuracy.max.room.level<- c(totalAccuracy.max.room.level, cv_ac.max.room.level)
  
  #AIC
  print(paste('Current AIC:',AIC(max.room.level), 'for CV', cv))
  totalAIC.max.room.level <- c(totalAIC.max.room.level, AIC(max.room.level))
}

#max.time.level model
totalAccuracy.max.time.level <- c()
totalAIC.max.time.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  max.time.level <- multinom(Binned_Occupancy ~ Wifi_Max_logs+Factor_Time+Course_Level, data=dataTrain,maxit=1000, trace = T)
  pred.max.time.level <- predict(max.time.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.max.time.level <- postResample(dataTest$Binned_Occupancy, pred.max.time.level)[[1]]
  print(paste('Current Accuracy for max model:',cv_ac.max.time.level,'for CV:',cv))
  totalAccuracy.max.time.level<- c(totalAccuracy.max.time.level, cv_ac.max.time.level)
  
  #AIC
  print(paste('Current AIC:',AIC(max.time.level), 'for CV', cv))
  totalAIC.max.time.level <- c(totalAIC.max.time.level, AIC(max.time.level))
}

#full model
totalAccuracy.max.full <- c()
totalAIC.max.full <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  max.full <- multinom(Binned_Occupancy ~Wifi_Max_logs + Room + Factor_Time + Course_Level, data=dataTrain,maxit=1000, trace = T)
  pred.max.full <- predict(max.full, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.max.full <- postResample(dataTest$Binned_Occupancy, pred.max.full)[[1]]
  print(paste('Current Accuracy for full model:',cv_ac.max.full,'for CV:',cv))
  totalAccuracy.max.full <- c(totalAccuracy.max.full, cv_ac.max.full)
  
  #AIC
  print(paste('Current AIC:',AIC(max.full), 'for CV', cv))
  totalAIC.max.full <- c(totalAIC.max.full, AIC(max.full))
}

#ACCURACIES
#NULL MODEL
print(paste('The accuracy for null model is:',mean(totalAccuracy.null),' and the AIC is:',mean(totalAIC.null)))
#max MODEL
print(paste('The accuracy for max model is:',mean(totalAccuracy.max),' and the AIC is:',mean(totalAIC.max)))
#max.ROOM
print(paste('The accuracy for max.room model is:',mean(totalAccuracy.max.room),' and the AIC is:',mean(totalAIC.max.room)))
#max.TIME
print(paste('The accuracy for max.time model is:',mean(totalAccuracy.max.time),' and the AIC is:',mean(totalAIC.max.time)))
#max.LEVEL
print(paste('The accuracy for max.level model is:',mean(totalAccuracy.max.time),' and the AIC is:',mean(totalAIC.max.time)))
#max.ROOM.TIME
print(paste('The accuracy for max.room.time model is:',mean(totalAccuracy.max.room.time),' and the AIC is:',mean(totalAIC.max.room.time)))
#max.ROOM.LEVEL
print(paste('The accuracy for max.room.level model is:',mean(totalAccuracy.max.room.level),' and the AIC is:',mean(totalAIC.max.room.level)))
#max.TIME.LEVEL
print(paste('The accuracy for max.time.level model is:',mean(totalAccuracy.max.time.level),' and the AIC is:',mean(totalAIC.max.time.level)))
#max.FULL
print(paste('The accuracy for max.full model is:',mean(totalAccuracy.max.full),' and the AIC is:',mean(totalAIC.max.full)))

#The best model in term of accuracy and AIC was MAX.ROOM with acc = 0.55  and AIC is: 385.
#However the accuracy and the AIC of the AVG.MAX model was better and we keep it as best model and we will run it on the whole dataset.

final.avg.room.level <- multinom(Binned_Occupancy ~ Wifi_Average_logs+Room+Course_Level, data=AnalysisTable,maxit=1000)

#EXAMINE THE MODEL
#examine the changes in predicted probability associated with the 2 response features
dses <- data.frame(Binned_occupancy=AnalysisTable$Binned_Occupancy,Room=AnalysisTable$Room,Course_Level=AnalysisTable$Course_Level,Wifi_Average_logs = mean(AnalysisTable$Wifi_Average_logs))
predict(final.avg.room.level, newdata = dses, "probs")

## store the predicted probabilities for each value of ses and write
pp.write <- cbind(dses, predict(final.avg.room.level, newdata = dses, type = "probs", se = TRUE))

## calculate the mean probabilities within each level of room
by(pp.write[, 5:8], pp.write$Room, colMeans)

by(pp.write[, 5:8], pp.write$Course_Level, colMeans)

#ORDINAL REGRESSION
#null model
totalAccuracy.ord.null <- c()
totalAIC.ord.null <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.null <- polr(Binned_Occupancy ~ 1, data=dataTrain, Hess=TRUE)
  pred.ord.null <- predict(ord.null, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.null <- postResample(dataTest$Binned_Occupancy, pred.ord.null)[[1]]
  print(paste('Current Accuracy for ordinal null model:',cv_ac.null,'for CV:',cv))
  totalAccuracy.ord.null <- c(totalAccuracy.ord.null, cv_ac.ord.null)
  #AIC
  print(paste('Current AIC:',AIC(ord.null), 'for CV', cv))
  totalAIC.ord.null <- c(totalAIC.ord.null, AIC(ord.null))
}

#CASE1: AVERAGE MODEL

#ord.avg model
totalAccuracy.ord.avg <- c()
totalAIC.ord.avg <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.avg <- polr(Binned_Occupancy ~ Wifi_Average_logs, data=dataTrain,Hess=TRUE)
  pred.ord.avg <- predict(ord.avg, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.avg <- postResample(dataTest$Binned_Occupancy, pred.ord.avg)[[1]]
  print(paste('Current Accuracy for ordinal avg model:',cv_ac.ord.avg,'for CV:',cv))
  totalAccuracy.ord.avg <- c(totalAccuracy.ord.avg, cv_ac.ord.avg)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.avg), 'for CV', cv))
  totalAIC.ord.avg <- c(totalAIC.ord.avg, AIC(ord.avg))
}


#ord.avg.room model
totalAccuracy.ord.avg.room <- c()
totalAIC.ord.avg.room <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.avg.room <- polr(Binned_Occupancy ~ Wifi_Average_logs+Room, data=dataTrain,Hess=TRUE)
  pred.ord.avg.room <- predict(ord.avg.room, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.avg.room <- postResample(dataTest$Binned_Occupancy, pred.ord.avg.room)[[1]]
  print(paste('Current Accuracy for ordinal avg room model:',cv_ac.ord.avg.room,'for CV:',cv))
  totalAccuracy.ord.avg.room <- c(totalAccuracy.ord.avg.room, cv_ac.ord.avg.room)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.avg.room), 'for CV', cv))
  totalAIC.ord.avg.room <- c(totalAIC.ord.avg.room, AIC(ord.avg.room))
}

#ord.avg.time model
totalAccuracy.ord.avg.time <- c()
totalAIC.ord.avg.time <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.avg.time <- polr(Binned_Occupancy ~ Wifi_Average_logs+Factor_Time, data=dataTrain,Hess=TRUE)
  pred.ord.avg.time <- predict(ord.avg.time, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.avg.time <- postResample(dataTest$Binned_Occupancy, pred.ord.avg.time)[[1]]
  print(paste('Current Accuracy for avg model:',cv_ac.ord.avg.time,'for CV:',cv))
  totalAccuracy.ord.avg.time <- c(totalAccuracy.ord.avg.time, cv_ac.ord.avg.time)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.avg.time), 'for CV', cv))
  totalAIC.ord.avg.time <- c(totalAIC.ord.avg.time, AIC(ord.avg.time))
}

#ord.avg.level model
totalAccuracy.ord.avg.level <- c()
totalAIC.ord.avg.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.avg.level <- polr(Binned_Occupancy ~ Wifi_Average_logs+ Course_Level, data=dataTrain,Hess=TRUE)
  pred.ord.avg.level <- predict(ord.avg.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.avg.level <- postResample(dataTest$Binned_Occupancy, pred.ord.avg.level)[[1]]
  print(paste('Current Accuracy for ord.ord.avg model:',cv_ac.ord.avg.level,'for CV:',cv))
  totalAccuracy.ord.avg.level <- c(totalAccuracy.ord.avg.level, cv_ac.ord.avg.level)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.avg.level), 'for CV', cv))
  totalAIC.ord.avg.level <- c(totalAIC.ord.avg.level, AIC(ord.avg.level))
}

#ord.avg.room.time model
totalAccuracy.ord.avg.room.time <- c()
totalAIC.ord.avg.room.time <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.avg.room.time <- polr(Binned_Occupancy ~ Wifi_Average_logs+Room+Factor_Time, data=dataTrain,Hess=TRUE)
  pred.ord.avg.room.time <- predict(ord.avg.room.time, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.avg.room.time <- postResample(dataTest$Binned_Occupancy, pred.ord.avg.room.time)[[1]]
  print(paste('Current Accuracy for ord.ord.avg model:',cv_ac.ord.avg.room.time,'for CV:',cv))
  totalAccuracy.ord.avg.room.time<- c(totalAccuracy.ord.avg.room.time, cv_ac.ord.avg.room.time)
  #AIC
  print(paste('Current AIC:',AIC(ord.avg.room.time), 'for CV', cv))
  totalAIC.ord.avg.room.time <- c(totalAIC.ord.avg.room.time, AIC(ord.avg.room.time))
}

#ord.avg.room.level model
totalAccuracy.ord.avg.room.level <- c()
totalAIC.ord.avg.room.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.avg.room.level <- polr(Binned_Occupancy ~ Wifi_Average_logs+Room+Course_Level, data=dataTrain,Hess=TRUE)
  pred.ord.avg.room.level <- predict(ord.avg.room.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.avg.room.level <- postResample(dataTest$Binned_Occupancy, pred.ord.avg.room.level)[[1]]
  print(paste('Current Accuracy for ord.ord.avg model:',cv_ac.ord.avg.room.level,'for CV:',cv))
  totalAccuracy.ord.avg.room.level<- c(totalAccuracy.ord.avg.room.level, cv_ac.ord.avg.room.level)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.avg.room.level), 'for CV', cv))
  totalAIC.ord.avg.room.level <- c(totalAIC.ord.avg.room.level, AIC(ord.avg.room.level))
}

#ord.avg.time.level model
totalAccuracy.ord.avg.time.level <- c()
totalAIC.ord.avg.time.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.avg.time.level <- polr(Binned_Occupancy ~ Wifi_Average_logs+Factor_Time+Course_Level, data=dataTrain,Hess=TRUE)
  pred.ord.avg.time.level <- predict(ord.avg.time.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.avg.time.level <- postResample(dataTest$Binned_Occupancy, pred.ord.avg.time.level)[[1]]
  print(paste('Current Accuracy for ord.ord.avg model:',cv_ac.ord.avg.time.level,'for CV:',cv))
  totalAccuracy.ord.avg.time.level<- c(totalAccuracy.ord.avg.time.level, cv_ac.ord.avg.time.level)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.avg.time.level), 'for CV', cv))
  totalAIC.ord.avg.time.level <- c(totalAIC.ord.avg.time.level, AIC(ord.avg.time.level))
}

#full model
totalAccuracy.ord.avg.full <- c()
totalAIC.ord.avg.full <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.avg.full <- polr(Binned_Occupancy ~Wifi_Average_logs + Room + Factor_Time + Course_Level, data=dataTrain,Hess=TRUE)
  pred.ord.avg.full <- predict(ord.avg.full, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.avg.full <- postResample(dataTest$Binned_Occupancy, pred.ord.avg.full)[[1]]
  print(paste('Current Accuracy for full model:',cv_ac.ord.avg.full,'for CV:',cv))
  totalAccuracy.ord.avg.full <- c(totalAccuracy.ord.avg.full, cv_ac.ord.avg.full)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.avg.full), 'for CV', cv))
  totalAIC.ord.avg.full <- c(totalAIC.ord.avg.full, AIC(ord.avg.full))
}

#ACCURACIES
#NULL MODEL
print(paste('The accuracy for null model is:',mean(totalAccuracy.null),' and the AIC is:',mean(totalAIC.null)))
#AVG MODEL
print(paste('The accuracy for ord.avg model is:',mean(totalAccuracy.ord.avg),' and the AIC is:',mean(totalAIC.ord.avg)))
#ord.avg.ROOM
print(paste('The accuracy for ord.avg.room model is:',mean(totalAccuracy.ord.avg.room),' and the AIC is:',mean(totalAIC.ord.avg.room)))
#ord.avg.TIME
print(paste('The accuracy for ord.avg.time model is:',mean(totalAccuracy.ord.avg.time),' and the AIC is:',mean(totalAIC.ord.avg.time)))
#ord.avg.LEVEL
print(paste('The accuracy for ord.avg.level model is:',mean(totalAccuracy.ord.avg.time),' and the AIC is:',mean(totalAIC.ord.avg.time)))
#ord.avg.ROOM.TIME
print(paste('The accuracy for ord.avg.room.time model is:',mean(totalAccuracy.ord.avg.room.time),' and the AIC is:',mean(totalAIC.ord.avg.room.time)))
#ord.avg.ROOM.LEVEL
print(paste('The accuracy for ord.avg.room.level model is:',mean(totalAccuracy.ord.avg.room.level),' and the AIC is:',mean(totalAIC.ord.avg.room.level)))
#ord.avg.TIME.LEVEL
print(paste('The accuracy for ord.avg.time.level model is:',mean(totalAccuracy.ord.avg.time.level),' and the AIC is:',mean(totalAIC.ord.avg.time.level)))
#ord.avg.FULL
print(paste('The accuracy for ord.avg.full model is:',mean(totalAccuracy.ord.avg.full),' and the AIC is:',mean(totalAIC.ord.avg.full)))


#AVG.ROOM was the best model in term of AIC and accuracy --> acc= 0.575 and AIC = 377. The ordinal regression in this case did not improve the accuracy.

#CASE2: MAX MODELS

#max model
totalAccuracy.ord.max <- c()
totalAIC.ord.max <- c()
for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.max <- polr(Binned_Occupancy ~ Wifi_Max_logs, data=dataTrain,Hess=TRUE)
  pred.ord.max <- predict(ord.max, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.max <- postResample(dataTest$Binned_Occupancy, pred.ord.max)[[1]]
  print(paste('Current Accuracy for ord.max model:',cv_ac.ord.max,'for CV:',cv))
  totalAccuracy.ord.max <- c(totalAccuracy.ord.max, cv_ac.ord.max)
  #AIC
  print(paste('Current AIC:',AIC(ord.max), 'for CV', cv))
  totalAIC.ord.max <- c(totalAIC.ord.max, AIC(ord.max))
}


#ord.max.room model

totalAccuracy.ord.max.room <- c()
totalAIC.ord.max.room <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.max.room <- polr(Binned_Occupancy ~ Wifi_Max_logs+Room, data=dataTrain,Hess=TRUE)
  pred.ord.max.room <- predict(ord.max.room, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.max.room <- postResample(dataTest$Binned_Occupancy, pred.ord.max.room)[[1]]
  print(paste('Current Accuracy for ord.max model:',cv_ac.ord.max.room,'for CV:',cv))
  totalAccuracy.ord.max.room <- c(totalAccuracy.ord.max.room, cv_ac.ord.max.room)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.max.room), 'for CV', cv))
  totalAIC.ord.max.room <- c(totalAIC.ord.max.room, AIC(ord.max.room))
}


#ord.max.time model
totalAccuracy.ord.max.time <- c()
totalAIC.ord.max.time <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.max.time <- polr(Binned_Occupancy ~ Wifi_Max_logs+Factor_Time, data=dataTrain,Hess=TRUE)
  pred.ord.max.time <- predict(ord.max.time, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.max.time <- postResample(dataTest$Binned_Occupancy, pred.ord.max.time)[[1]]
  print(paste('Current Accuracy for ord.max model:',cv_ac.ord.max.time,'for CV:',cv))
  totalAccuracy.ord.max.time <- c(totalAccuracy.ord.max.time, cv_ac.ord.max.time)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.max.time), 'for CV', cv))
  totalAIC.ord.max.time <- c(totalAIC.ord.max.time, AIC(ord.max.time))
}


#ord.max.level model
totalAccuracy.ord.max.level <- c()
totalAIC.ord.max.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.max.level <- polr(Binned_Occupancy ~ Wifi_Max_logs+Course_Level, data=dataTrain,Hess=TRUE)
  pred.ord.max.level <- predict(ord.max.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.max.level <- postResample(dataTest$Binned_Occupancy, pred.ord.max.level)[[1]]
  print(paste('Current Accuracy for ord.max model:',cv_ac.ord.max.level,'for CV:',cv))
  totalAccuracy.ord.max.level <- c(totalAccuracy.ord.max.level, cv_ac.ord.max.level)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.max.level), 'for CV', cv))
  totalAIC.ord.max.level <- c(totalAIC.ord.max.level, AIC(ord.max.level))
}

#ord.max.room.time model
totalAccuracy.ord.max.room.time <- c()
totalAIC.ord.max.room.time <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.max.room.time <- polr(Binned_Occupancy ~ Wifi_Max_logs+Room+Factor_Time, data=dataTrain,Hess=TRUE)
  pred.ord.max.room.time <- predict(ord.max.room.time, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.max.room.time <- postResample(dataTest$Binned_Occupancy, pred.ord.max.room.time)[[1]]
  print(paste('Current Accuracy for ord.max model:',cv_ac.ord.max.room.time,'for CV:',cv))
  totalAccuracy.ord.max.room.time<- c(totalAccuracy.ord.max.room.time, cv_ac.ord.max.room.time)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.max.room.time), 'for CV', cv))
  totalAIC.ord.max.room.time <- c(totalAIC.ord.max.room.time, AIC(ord.max.room.time))
}


#ord.max.room.level model
totalAccuracy.ord.max.room.level <- c()
totalAIC.ord.max.room.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.max.room.level <- polr(Binned_Occupancy ~ Wifi_Max_logs+Room+Course_Level, data=dataTrain,Hess=TRUE)
  pred.ord.max.room.level <- predict(ord.max.room.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.max.room.level <- postResample(dataTest$Binned_Occupancy, pred.ord.max.room.level)[[1]]
  print(paste('Current Accuracy for ord.max model:',cv_ac.ord.max.room.level,'for CV:',cv))
  totalAccuracy.ord.max.room.level<- c(totalAccuracy.ord.max.room.level, cv_ac.ord.max.room.level)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.max.room.level), 'for CV', cv))
  totalAIC.ord.max.room.level <- c(totalAIC.ord.max.room.level, AIC(ord.max.room.level))
}

#ord.max.time.level model
totalAccuracy.ord.max.time.level <- c()
totalAIC.ord.max.time.level <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.max.time.level <- polr(Binned_Occupancy ~ Wifi_Max_logs+Factor_Time+Course_Level, data=dataTrain,Hess=TRUE)
  pred.ord.max.time.level <- predict(ord.max.time.level, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.max.time.level <- postResample(dataTest$Binned_Occupancy, pred.ord.max.time.level)[[1]]
  print(paste('Current Accuracy for ord.max model:',cv_ac.ord.max.time.level,'for CV:',cv))
  totalAccuracy.ord.max.time.level<- c(totalAccuracy.ord.max.time.level, cv_ac.ord.max.time.level)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.max.time.level), 'for CV', cv))
  totalAIC.ord.max.time.level <- c(totalAIC.ord.max.time.level, AIC(ord.max.time.level))
}

#full model
totalAccuracy.ord.max.full <- c()
totalAIC.ord.max.full <- c()

for (cv in seq(1:cv)) {
  # assign chunk to data test
  dataTestIndex <- c((cv * cvDivider):(cv * cvDivider + cvDivider))
  dataTest <- AnalysisTable[dataTestIndex,]
  # everything else to train
  dataTrain <- AnalysisTable[-dataTestIndex,]
  
  ord.max.full <- polr(Binned_Occupancy ~Wifi_Max_logs + Room + Factor_Time + Course_Level, data=dataTrain,Hess=TRUE)
  pred.ord.max.full <- predict(ord.max.full, newdata=dataTest, type="class")
  
  #  classification error
  cv_ac.ord.max.full <- postResample(dataTest$Binned_Occupancy, pred.ord.max.full)[[1]]
  print(paste('Current Accuracy for full model:',cv_ac.ord.max.full,'for CV:',cv))
  totalAccuracy.ord.max.full <- c(totalAccuracy.ord.max.full, cv_ac.ord.max.full)
  
  #AIC
  print(paste('Current AIC:',AIC(ord.max.full), 'for CV', cv))
  totalAIC.ord.max.full <- c(totalAIC.ord.max.full, AIC(ord.max.full))
}

#ACCURACIES
#NULL MODEL
print(paste('The accuracy for null model is:',mean(totalAccuracy.null),' and the AIC is:',mean(totalAIC.null)))
#max MODEL
print(paste('The accuracy for ord.max model is:',mean(totalAccuracy.ord.max),' and the AIC is:',mean(totalAIC.ord.max)))
#ord.max.ROOM
print(paste('The accuracy for ord.max.room model is:',mean(totalAccuracy.ord.max.room),' and the AIC is:',mean(totalAIC.ord.max.room)))
#ord.max.TIME
print(paste('The accuracy for ord.max.time model is:',mean(totalAccuracy.ord.max.time),' and the AIC is:',mean(totalAIC.ord.max.time)))
#ord.max.LEVEL
print(paste('The accuracy for ord.max.level model is:',mean(totalAccuracy.ord.max.time),' and the AIC is:',mean(totalAIC.ord.max.time)))
#ord.max.ROOM.TIME
print(paste('The accuracy for ord.max.room.time model is:',mean(totalAccuracy.ord.max.room.time),' and the AIC is:',mean(totalAIC.ord.max.room.time)))
#ord.max.ROOM.LEVEL
print(paste('The accuracy for ord.max.room.level model is:',mean(totalAccuracy.ord.max.room.level),' and the AIC is:',mean(totalAIC.ord.max.room.level)))
#ord.max.TIME.LEVEL
print(paste('The accuracy for ord.max.time.level model is:',mean(totalAccuracy.ord.max.time.level),' and the AIC is:',mean(totalAIC.ord.max.time.level)))
#ord.max.FULL
print(paste('The accuracy for ord.max.full model is:',mean(totalAccuracy.ord.max.full),' and the AIC is:',mean(totalAIC.ord.max.full)))

#The best model in term of AIC and accuracy was the max.room --> accuracy =0.57  and AIC is: 391

